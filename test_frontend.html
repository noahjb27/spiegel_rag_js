<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPIEGEL RAG Frontend Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 4px solid;
        }
        .test-pass {
            background-color: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        .test-fail {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }
        .test-info {
            background-color: #d1ecf1;
            border-color: #17a2b8;
            color: #0c5460;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .feature-test {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }
        .feature-test h3 {
            margin-top: 0;
            color: #333;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-pass { background-color: #28a745; }
        .status-fail { background-color: #dc3545; }
        .status-pending { background-color: #ffc107; }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>üöÄ SPIEGEL RAG Frontend Feature Test</h1>
        <p>This page tests the frontend functionality of your SPIEGEL RAG system.</p>
        
        <div class="test-result test-info">
            <strong>Instructions:</strong>
            <ol>
                <li>Make sure your backend is running on <code>http://127.0.0.1:5001</code></li>
                <li>Make sure your frontend is running on <code>http://localhost:3000</code></li>
                <li>Click "Run All Tests" to test all features</li>
                <li>Or click individual test buttons to test specific features</li>
            </ol>
        </div>

        <div>
            <button onclick="runAllTests()" id="runAllBtn">Run All Tests</button>
            <button onclick="clearResults()">Clear Results</button>
            <button onclick="openFrontend()">Open Frontend App</button>
        </div>

        <div id="testResults"></div>
    </div>

    <div class="test-grid">
        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-backend"></span>Backend Connectivity</h3>
            <p>Test if the backend API is accessible and responding.</p>
            <button onclick="testBackendConnectivity()">Test Backend</button>
            <div id="result-backend"></div>
        </div>

        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-config"></span>Configuration API</h3>
            <p>Test the configuration endpoint for available models and settings.</p>
            <button onclick="testConfigAPI()">Test Config</button>
            <div id="result-config"></div>
        </div>

        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-search"></span>Standard Search</h3>
            <p>Test the standard search functionality with a sample query.</p>
            <button onclick="testStandardSearch()">Test Search</button>
            <div id="result-search"></div>
        </div>

        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-llm"></span>LLM-Assisted Search</h3>
            <p>Test the LLM-assisted search with multi-stage filtering.</p>
            <button onclick="testLLMAssistedSearch()">Test LLM Search</button>
            <div id="result-llm"></div>
        </div>

        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-keywords"></span>Keyword Expansion</h3>
            <p>Test the keyword expansion feature for semantic similarity.</p>
            <button onclick="testKeywordExpansion()">Test Keywords</button>
            <div id="result-keywords"></div>
        </div>

        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-analysis"></span>Analysis</h3>
            <p>Test the analysis endpoint with sample chunks.</p>
            <button onclick="testAnalysis()">Test Analysis</button>
            <div id="result-analysis"></div>
        </div>

        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-download"></span>Downloads</h3>
            <p>Test CSV and JSON download functionality.</p>
            <button onclick="testDownloads()">Test Downloads</button>
            <div id="result-download"></div>
        </div>

        <div class="feature-test">
            <h3><span class="status-indicator status-pending" id="status-frontend"></span>Frontend App</h3>
            <p>Test if the React frontend is accessible and loads properly.</p>
            <button onclick="testFrontendApp()">Test Frontend</button>
            <div id="result-frontend"></div>
        </div>
    </div>

    <script>
        const BACKEND_URL = 'http://127.0.0.1:5001';
        const FRONTEND_URL = 'http://localhost:3000';
        let testResults = [];

        function addResult(testName, passed, message, details = null) {
            const result = {
                name: testName,
                passed: passed,
                message: message,
                details: details,
                timestamp: new Date().toISOString()
            };
            testResults.push(result);
            updateTestDisplay();
        }

        function updateTestDisplay() {
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = '';

            if (testResults.length === 0) return;

            const summary = document.createElement('div');
            const passed = testResults.filter(r => r.passed).length;
            const total = testResults.length;
            summary.className = `test-result ${passed === total ? 'test-pass' : 'test-fail'}`;
            summary.innerHTML = `<strong>Test Summary: ${passed}/${total} tests passed</strong>`;
            resultsDiv.appendChild(summary);

            testResults.forEach(result => {
                const div = document.createElement('div');
                div.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
                div.innerHTML = `
                    <strong>${result.passed ? '‚úÖ' : '‚ùå'} ${result.name}</strong><br>
                    ${result.message}
                    ${result.details ? `<br><small>Details: ${JSON.stringify(result.details)}</small>` : ''}
                `;
                resultsDiv.appendChild(div);
            });
        }

        function updateStatusIndicator(testId, passed) {
            const indicator = document.getElementById(`status-${testId}`);
            indicator.className = `status-indicator ${passed ? 'status-pass' : 'status-fail'}`;
        }

        function showResult(testId, passed, message, details = null) {
            const resultDiv = document.getElementById(`result-${testId}`);
            resultDiv.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            resultDiv.innerHTML = `
                <strong>${passed ? '‚úÖ' : '‚ùå'} ${message}</strong>
                ${details ? `<br><small>${JSON.stringify(details)}</small>` : ''}
            `;
            updateStatusIndicator(testId, passed);
        }

        async function testBackendConnectivity() {
            try {
                const response = await fetch(`${BACKEND_URL}/api/config/config`);
                if (response.ok) {
                    const config = await response.json();
                    showResult('backend', true, 'Backend is accessible', {
                        models: config.available_models?.length || 0,
                        yearRange: config.year_range
                    });
                    addResult('Backend Connectivity', true, 'Backend is accessible');
                } else {
                    showResult('backend', false, `Backend returned status ${response.status}`);
                    addResult('Backend Connectivity', false, `Backend returned status ${response.status}`);
                }
            } catch (error) {
                showResult('backend', false, `Backend not accessible: ${error.message}`);
                addResult('Backend Connectivity', false, `Backend not accessible: ${error.message}`);
            }
        }

        async function testConfigAPI() {
            try {
                const response = await fetch(`${BACKEND_URL}/api/config/config`);
                if (response.ok) {
                    const config = await response.json();
                    const hasRequiredKeys = ['available_models', 'model_display_names', 'chunk_sizes', 'year_range']
                        .every(key => key in config);
                    
                    if (hasRequiredKeys) {
                        showResult('config', true, 'Configuration API working', {
                            models: config.available_models,
                            yearRange: config.year_range
                        });
                        addResult('Configuration API', true, 'Configuration API working');
                    } else {
                        showResult('config', false, 'Configuration missing required keys');
                        addResult('Configuration API', false, 'Configuration missing required keys');
                    }
                } else {
                    showResult('config', false, `Config API failed with status ${response.status}`);
                    addResult('Configuration API', false, `Config API failed with status ${response.status}`);
                }
            } catch (error) {
                showResult('config', false, `Config API error: ${error.message}`);
                addResult('Configuration API', false, `Config API error: ${error.message}`);
            }
        }

        async function testStandardSearch() {
            try {
                const searchParams = {
                    retrieval_query: "Berliner Mauer",
                    year_start: 1960,
                    year_end: 1970,
                    chunk_size: 3000,
                    top_k: 5,
                    keywords: "mauer AND berlin",
                    search_in: ["Text"],
                    use_semantic_expansion: false,
                    use_time_intervals: false
                };

                const response = await fetch(`${BACKEND_URL}/api/search/standard`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(searchParams)
                });

                if (response.ok) {
                    const result = await response.json();
                    const chunks = result.chunks || [];
                    
                    if (chunks.length > 0) {
                        showResult('search', true, `Found ${chunks.length} chunks`, {
                            searchTime: result.metadata?.search_time,
                            sampleTitle: chunks[0]?.metadata?.Artikeltitel
                        });
                        addResult('Standard Search', true, `Found ${chunks.length} chunks`);
                    } else {
                        showResult('search', false, 'Search returned no results');
                        addResult('Standard Search', false, 'Search returned no results');
                    }
                } else {
                    showResult('search', false, `Search failed with status ${response.status}`);
                    addResult('Standard Search', false, `Search failed with status ${response.status}`);
                }
            } catch (error) {
                showResult('search', false, `Search error: ${error.message}`);
                addResult('Standard Search', false, `Search error: ${error.message}`);
            }
        }

        async function testLLMAssistedSearch() {
            try {
                const searchParams = {
                    retrieval_query: "Berliner Mauer Bau",
                    year_start: 1960,
                    year_end: 1970,
                    chunk_size: 3000,
                    llm_assisted_keywords: "mauer AND berlin",
                    llm_assisted_search_in: ["Text"],
                    llm_assisted_use_time_intervals: true,
                    llm_assisted_time_interval_size: 5,
                    chunks_per_interval_initial: 20,
                    chunks_per_interval_final: 10,
                    llm_assisted_min_retrieval_score: 0.25,
                    llm_assisted_model: "hu-llm3",
                    llm_assisted_temperature: 0.2,
                    llm_assisted_system_prompt_text: "Du bewertest Textabschnitte aus SPIEGEL-Artikeln..."
                };

                const response = await fetch(`${BACKEND_URL}/api/search/llm-assisted`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(searchParams)
                });

                if (response.ok) {
                    const result = await response.json();
                    const chunks = result.chunks || [];
                    const hasLLMScores = chunks.some(chunk => 'llm_evaluation_score' in chunk);
                    
                    if (chunks.length > 0) {
                        showResult('llm', true, `Found ${chunks.length} chunks with LLM evaluation`, {
                            hasLLMScores: hasLLMScores,
                            searchTime: result.metadata?.search_time
                        });
                        addResult('LLM-Assisted Search', true, `Found ${chunks.length} chunks with LLM evaluation`);
                    } else {
                        showResult('llm', false, 'LLM-assisted search returned no results');
                        addResult('LLM-Assisted Search', false, 'LLM-assisted search returned no results');
                    }
                } else {
                    showResult('llm', false, `LLM search failed with status ${response.status}`);
                    addResult('LLM-Assisted Search', false, `LLM search failed with status ${response.status}`);
                }
            } catch (error) {
                showResult('llm', false, `LLM search error: ${error.message}`);
                addResult('LLM-Assisted Search', false, `LLM search error: ${error.message}`);
            }
        }

        async function testKeywordExpansion() {
            try {
                const response = await fetch(`${BACKEND_URL}/api/keywords/expand?expression=mauer&factor=5`);
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result && result.mauer && result.mauer.length > 0) {
                        showResult('keywords', true, `Found ${result.mauer.length} similar words`, {
                            sampleWords: result.mauer.slice(0, 3).map(w => w.word)
                        });
                        addResult('Keyword Expansion', true, `Found ${result.mauer.length} similar words`);
                    } else {
                        showResult('keywords', false, 'Keyword expansion returned no results');
                        addResult('Keyword Expansion', false, 'Keyword expansion returned no results');
                    }
                } else {
                    showResult('keywords', false, `Keyword expansion failed with status ${response.status}`);
                    addResult('Keyword Expansion', false, `Keyword expansion failed with status ${response.status}`);
                }
            } catch (error) {
                showResult('keywords', false, `Keyword expansion error: ${error.message}`);
                addResult('Keyword Expansion', false, `Keyword expansion error: ${error.message}`);
            }
        }

        async function testAnalysis() {
            try {
                // First get some chunks
                const searchParams = {
                    retrieval_query: "Berliner Mauer",
                    year_start: 1960,
                    year_end: 1970,
                    chunk_size: 3000,
                    top_k: 2,
                    use_semantic_expansion: false
                };

                const searchResponse = await fetch(`${BACKEND_URL}/api/search/standard`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(searchParams)
                });

                if (!searchResponse.ok) {
                    showResult('analysis', false, 'Could not get chunks for analysis');
                    addResult('Analysis', false, 'Could not get chunks for analysis');
                    return;
                }

                const searchResult = await searchResponse.json();
                const chunks = searchResult.chunks || [];

                if (chunks.length === 0) {
                    showResult('analysis', false, 'No chunks available for analysis');
                    addResult('Analysis', false, 'No chunks available for analysis');
                    return;
                }

                // Now test analysis
                const analysisParams = {
                    user_prompt: "Wie wurde die Berliner Mauer in den Medien dargestellt?",
                    chunks_to_analyze: chunks.slice(0, 2),
                    model_selection: "hu-llm3",
                    system_prompt_text: "Du bist ein Historiker. Beantworte die Frage basierend auf den bereitgestellten Texten.",
                    temperature: 0.3
                };

                const analysisResponse = await fetch(`${BACKEND_URL}/api/search/analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(analysisParams)
                });

                if (analysisResponse.ok) {
                    const result = await analysisResponse.json();
                    const answer = result.answer || '';
                    
                    if (answer.length > 10) {
                        showResult('analysis', true, `Analysis completed. Answer length: ${answer.length} chars`, {
                            modelUsed: result.metadata?.model_used,
                            analysisTime: result.metadata?.analysis_time
                        });
                        addResult('Analysis', true, `Analysis completed. Answer length: ${answer.length} chars`);
                    } else {
                        showResult('analysis', false, 'Analysis returned empty or too short answer');
                        addResult('Analysis', false, 'Analysis returned empty or too short answer');
                    }
                } else {
                    showResult('analysis', false, `Analysis failed with status ${analysisResponse.status}`);
                    addResult('Analysis', false, `Analysis failed with status ${analysisResponse.status}`);
                }
            } catch (error) {
                showResult('analysis', false, `Analysis error: ${error.message}`);
                addResult('Analysis', false, `Analysis error: ${error.message}`);
            }
        }

        async function testDownloads() {
            try {
                // First get some chunks
                const searchParams = {
                    retrieval_query: "Berliner Mauer",
                    year_start: 1960,
                    year_end: 1970,
                    chunk_size: 3000,
                    top_k: 3,
                    use_semantic_expansion: false
                };

                const searchResponse = await fetch(`${BACKEND_URL}/api/search/standard`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(searchParams)
                });

                if (!searchResponse.ok) {
                    showResult('download', false, 'Could not get chunks for download test');
                    addResult('Downloads', false, 'Could not get chunks for download test');
                    return;
                }

                const searchResult = await searchResponse.json();

                // Test CSV download
                const csvResponse = await fetch(`${BACKEND_URL}/api/download/csv`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ retrieved_chunks: searchResult })
                });

                // Test JSON download
                const jsonResponse = await fetch(`${BACKEND_URL}/api/download/json`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ retrieved_chunks: searchResult })
                });

                const csvOk = csvResponse.ok && csvResponse.headers.get('content-type')?.includes('text/csv');
                const jsonOk = jsonResponse.ok && jsonResponse.headers.get('content-type')?.includes('application/json');

                if (csvOk && jsonOk) {
                    showResult('download', true, 'Both CSV and JSON downloads working', {
                        csvSize: csvResponse.headers.get('content-length'),
                        jsonSize: jsonResponse.headers.get('content-length')
                    });
                    addResult('Downloads', true, 'Both CSV and JSON downloads working');
                } else {
                    showResult('download', false, `Download issues - CSV: ${csvOk}, JSON: ${jsonOk}`);
                    addResult('Downloads', false, `Download issues - CSV: ${csvOk}, JSON: ${jsonOk}`);
                }
            } catch (error) {
                showResult('download', false, `Download test error: ${error.message}`);
                addResult('Downloads', false, `Download test error: ${error.message}`);
            }
        }

        async function testFrontendApp() {
            try {
                const response = await fetch(FRONTEND_URL);
                if (response.ok) {
                    const html = await response.text();
                    const hasReact = html.includes('react') || html.includes('React');
                    
                    showResult('frontend', true, 'Frontend is accessible', {
                        hasReact: hasReact,
                        status: response.status
                    });
                    addResult('Frontend App', true, 'Frontend is accessible');
                } else {
                    showResult('frontend', false, `Frontend returned status ${response.status}`);
                    addResult('Frontend App', false, `Frontend returned status ${response.status}`);
                }
            } catch (error) {
                showResult('frontend', false, `Frontend not accessible: ${error.message}`);
                addResult('Frontend App', false, `Frontend not accessible: ${error.message}`);
            }
        }

        async function runAllTests() {
            const runAllBtn = document.getElementById('runAllBtn');
            runAllBtn.disabled = true;
            runAllBtn.innerHTML = '<div class="loading"></div> Running Tests...';

            testResults = [];
            
            await testBackendConnectivity();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testConfigAPI();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testStandardSearch();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testLLMAssistedSearch();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testKeywordExpansion();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testAnalysis();
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            await testDownloads();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testFrontendApp();

            runAllBtn.disabled = false;
            runAllBtn.innerHTML = 'Run All Tests';
        }

        function clearResults() {
            testResults = [];
            updateTestDisplay();
            
            // Reset all status indicators
            document.querySelectorAll('.status-indicator').forEach(indicator => {
                indicator.className = 'status-indicator status-pending';
            });
            
            // Clear all result displays
            document.querySelectorAll('[id^="result-"]').forEach(div => {
                div.innerHTML = '';
                div.className = '';
            });
        }

        function openFrontend() {
            window.open(FRONTEND_URL, '_blank');
        }

        // Auto-run backend connectivity test on page load
        window.addEventListener('load', () => {
            testBackendConnectivity();
        });
    </script>
</body>
</html>
